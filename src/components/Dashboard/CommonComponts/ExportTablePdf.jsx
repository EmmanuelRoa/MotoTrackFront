import React from 'react';
import { jsPDF } from 'jspdf';
import mototrackLogo from '../../../assets/Lading/MotoTrackLogo-2.png';
// Import jspdf-autotable directly
import 'jspdf-autotable';

/**
 * Utility function to export table data to PDF
 * 
 * @param {Object} options Export options
 * @param {Array} options.columns Array of table column definitions
 * @param {Array} options.data Array of table data
 * @param {String} options.fileName Base filename for the export (without extension)
 * @param {String} options.title Title to show in the PDF
 * @param {String} options.subtitle Optional subtitle for the PDF
 * @param {Function} options.transformData Optional function to transform data before export
 * @param {Function} options.onSuccess Callback function to be called on successful export
 * @param {Function} options.onError Callback function to be called on export error
 * @param {Object} options.notificationSystem Notification system object
 * @returns {Promise<boolean>} Success status of the export operation
 */
export const exportTableToPdf = async ({
  columns = [],
  data = [],
  fileName = 'table-export',
  title = 'Table Export',
  subtitle = '',
  transformData,
  onSuccess,
  onError,
  notificationSystem // Recibir el objeto de notificación
}) => {
  // Translations
  const translations = {
    en: {
      exportSuccess: 'Export successful',
      exportError: 'Error exporting data',
      date: 'Date',
      time: 'Time',
      page: 'Page',
      of: 'of',
      generatedBy: 'Generated by MotoTrack System',
      report: 'Report',
      reportIntro: 'This report contains the information requested from the MotoTrack system as of',
      tableInfo: 'The information displayed corresponds to the data in the system at the time of generating this report.',
      confidential: 'CONFIDENTIAL - FOR INTERNAL USE ONLY',
      // Status translations
      MOTO_APROBADA: 'Approved',
      MOTO_PENDIENTE: 'Pending',
      MOTO_RECHAZADA: 'Rejected',
      APROBADO: 'Approved',
      PENDIENTE: 'Pending',
      RECHAZADO: 'Rejected'
    },
    es: {
      exportSuccess: 'Exportación exitosa',
      exportError: 'Error al exportar datos',
      date: 'Fecha',
      time: 'Hora',
      page: 'Página',
      of: 'de',
      generatedBy: 'Generado por el Sistema MotoTrack',
      report: 'Informe',
      reportIntro: 'Este informe contiene la información solicitada del sistema MotoTrack con fecha del',
      tableInfo: 'La información mostrada corresponde a los datos en el sistema al momento de generar este informe.',
      confidential: 'CONFIDENCIAL - SOLO PARA USO INTERNO',
      // Status translations
      MOTO_APROBADA: 'Aprobado',
      MOTO_PENDIENTE: 'Pendiente',
      MOTO_RECHAZADA: 'Rechazado',
      APROBADO: 'Aprobado',
      PENDIENTE: 'Pendiente',
      RECHAZADO: 'Rechazado'
    }
  };
  
  // Force Spanish translations
  const t = translations.es;
  
  // Define purple color - Updated to #635BFF
  const primaryColor = [99, 91, 255]; // RGB for #635BFF
  
  try {
    // First check if jsPDF is properly loaded
    if (!jsPDF) {
      throw new Error('jsPDF library not loaded');
    }

    // Prepare data for the table
    // Map columns to format expected by jspdf-autotable
    const tableColumns = columns
      .filter(col => col.key !== 'actions' && col.dataIndex !== 'actions' && col.key !== 'acciones') // Don't include action columns
      .map(col => ({
        header: col.title,
        dataKey: Array.isArray(col.dataIndex) ? col.dataIndex.join('.') : col.dataIndex || col.key
      }));
    
    // If transformData function is provided, use it
    let processedData = transformData ? transformData(data) : data;
    
    // Map data to format expected by jspdf-autotable
    const tableData = processedData.map(record => {
      const row = {};
      tableColumns.forEach(col => {
        const dataKey = col.dataKey;
        
        // Handle special case for estado/status
        if (dataKey === 'estado') {
          const statusValue = record[dataKey];
          row[dataKey] = t[statusValue] || statusValue; // Use translation if available
          return;
        }
        
        // Handle special case for asignadoA (handle object with nombre property)
        if (dataKey === 'asignadoA') {
          const assignedTo = record[dataKey];
          row[dataKey] = assignedTo && assignedTo.nombre ? assignedTo.nombre : '-';
          return;
        }
        
        if (dataKey.includes('.')) {
          // Handle nested properties
          const keys = dataKey.split('.');
          let value = record;
          for (const key of keys) {
            value = value && value[key];
          }
          
          // Check if value is an object with a 'nombre' property (common pattern)
          if (value && typeof value === 'object' && value.nombre) {
            row[dataKey] = value.nombre;
          } else {
            row[dataKey] = value !== undefined && value !== null ? String(value) : '';
          }
        } else {
          const value = record[dataKey];
          
          // Check if value is an object with a 'nombre' property
          if (value && typeof value === 'object' && value.nombre) {
            row[dataKey] = value.nombre;
          } else {
            row[dataKey] = value !== undefined && value !== null 
              ? String(value) 
              : '';
          }
        }
      });
      return row;
    });

    // Create the document
    const doc = new jsPDF({
      orientation: 'landscape',
      unit: 'mm',
      format: 'a4'
    });

    // Verify autoTable is available
    if (typeof doc.autoTable !== 'function') {
      throw new Error('PDF export plugin not properly initialized');
    }

    // Always set white background
    doc.setFillColor(255, 255, 255);
    doc.rect(0, 0, doc.internal.pageSize.getWidth(), doc.internal.pageSize.getHeight(), 'F');
    
    // Set text color to dark
    doc.setTextColor(30, 30, 30);

    // Get current date and time with Spanish locale
    const now = new Date();
    const formattedDate = now.toLocaleDateString('es-ES', {
      day: '2-digit',
      month: 'long',
      year: 'numeric'
    });
    const formattedTime = now.toLocaleTimeString('es-ES');
    
    // Add MotoTrack logo
    try {
      const loadImage = (src) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = 'Anonymous';
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
          };
          img.onerror = () => {
            console.error('Error loading image:', src);
            resolve(null);
          };
          img.src = src;
        });
      };
      
      const logoBase64 = await loadImage(mototrackLogo);
      if (logoBase64) {
        doc.addImage(logoBase64, 'PNG', 10, 10, 40, 20);
      }
    } catch (error) {
      console.error('Error loading logo:', error);
      // Continue without logo if it fails to load
    }
    
    // Add watermark
    try {
      const loadImage = (src) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = 'Anonymous';
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.globalAlpha = 0.05; // Very transparent
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
          };
          img.onerror = () => {
            console.error('Error loading image:', src);
            resolve(null);
          };
          img.src = src;
        });
      };
      
      const watermarkBase64 = await loadImage(mototrackLogo);
      if (watermarkBase64) {
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        
        // Add watermark in center of page
        doc.addImage(watermarkBase64, 'PNG', pageWidth/2 - 40, pageHeight/2 - 40, 80, 80);
      }
    } catch (error) {
      console.error('Error adding watermark:', error);
      // Continue without watermark if it fails
    }
    
    // Add title
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text(title, doc.internal.pageSize.getWidth() / 2, 20, { align: 'center' });
    
    // Add subtitle if provided
    if (subtitle) {
      doc.setFontSize(16);
      doc.setFont('helvetica', 'normal');
      doc.text(subtitle, doc.internal.pageSize.getWidth() / 2, 28, { align: 'center' });
    }
    
    // Add date and time
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`${t.date}: ${formattedDate}`, doc.internal.pageSize.getWidth() - 20, 15, { align: 'right' });
    doc.text(`${t.time}: ${formattedTime}`, doc.internal.pageSize.getWidth() - 20, 20, { align: 'right' });
    
    // Add introduction
    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    doc.text(`${t.reportIntro} ${formattedDate} ${t.time.toLowerCase()} ${formattedTime}.`, 15, 40);
    doc.text(t.tableInfo, 15, 47);
    
    // Add confidential notice
    doc.setFontSize(9);
    doc.setFont('helvetica', 'italic');
    doc.text(t.confidential, doc.internal.pageSize.getWidth() / 2, 55, { align: 'center' });
    
    // Configure autotable options with purple headers
    const tableOptions = {
      startY: 60,
      headStyles: {
        fillColor: primaryColor, // Use purple for headers
        textColor: [255, 255, 255],
        fontStyle: 'bold'
      },
      bodyStyles: {
        textColor: [50, 50, 50],
        fillColor: [255, 255, 255]
      },
      alternateRowStyles: {
        fillColor: [245, 245, 250] // Light purple tint for alternate rows
      },
      didDrawPage: (data) => {
        // Add footer on each page
        const pageCount = doc.internal.getNumberOfPages();
        const currentPage = data.pageNumber;
        doc.setFontSize(8);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(30, 30, 30);
        doc.text(
          `${t.page} ${currentPage} ${t.of} ${pageCount} - ${t.generatedBy}`,
          doc.internal.pageSize.getWidth() / 2,
          doc.internal.pageSize.getHeight() - 10,
          { align: 'center' }
        );
      },
      margin: { top: 60, bottom: 20 },
      styles: {
        fontSize: 9,
        cellPadding: 3,
        lineColor: [200, 200, 200],
        lineWidth: 0.1
      },
      showHead: 'everyPage',
      tableWidth: 'auto',
      theme: 'striped'
    };
    
    // Create the table using autoTable plugin
    if (typeof doc.autoTable !== 'function') {
      throw new Error("jspdf-autotable is not properly initialized. Make sure it's installed correctly.");
    }
    
    // When using autoTable, use it directly from the doc object
    doc.autoTable({
      ...tableOptions,
      columns: tableColumns.map(col => ({ 
        header: col.header, 
        dataKey: col.dataKey
      })),
      body: tableData
    });
    
    // Add summary information
    const finalY = (doc.lastAutoTable || {}).finalY || 60;
    if (finalY + 20 < doc.internal.pageSize.getHeight()) {
      // Only add summary if there's space on the current page
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text(`Total ${title}: ${tableData.length}`, 15, finalY + 10);
    }
    
    // Save the PDF
    doc.save(`${fileName}.pdf`);
    
    // Usar el sistema de notificaciones
    if (notificationSystem) {
      notificationSystem.success(
        'PDF Generado', 
        'El documento PDF ha sido generado exitosamente'
      );
    }
    
    // Usar el callback de éxito
    if (onSuccess) {
      onSuccess();
    }
    return true;
  } catch (error) {
    console.error('Error generating PDF:', error);
    
    // Mostrar notificación de error
    if (notificationSystem) {
      notificationSystem.error(
        'Error', 
        'Error al generar el PDF. Por favor, intente nuevamente.'
      );
    }
    
    // Usar el callback de error
    if (onError) {
      onError();
    }
    return false;
  }
};

/**
 * Component wrapper for exporting table data to PDF
 * This is a utility export rather than a visual component
 */
const ExportTablePdf = {
  exportTableToPdf
};

export default ExportTablePdf;